// Стандартная преамбула для заголовочного файла, гарантирующая его однократное
// включение
#ifndef __new_h
#define __new_h
#include "CChess.h"
// Нужно для size_t (беззнаковое целое с размером, соответствующим разрядности
// архитектуры)
#include <stddef.h>

// Нужно для va_list (тип, на котором основывается работа с переменным
// количеством аргументов у функций)
#include <stdarg.h>

/*
 * Базовая структура, в которой хранится информация о классе. Не путать со
 * структурой объекта! Для каждого класса существует одна-единственная глобальная
 * переменная типа Class.
 */
struct Class {
    // Размер объекта описываемого класса в байтах
    size_t size;
    /*
     * Указатель на функцию-конструктор, вызываемую в процессе создания
     * объекта. В качестве первого аргумента (self) функция принимает указатель
     * на выделенную под объект память (размером size).  Второй аргумент —
     * указатель на переменную типа va_list, которая «настроена» на первый аргумент
     * конструктора. Если конструктор принимает какие-либо аргументы, он должен
     * получить их с помощью нужного количества * вызовов va_arg.
     *
     * Функция-конструктор возвращает указатель, который будет
     * являться результатом вызова new. Как правило, она просто вернёт self.
     *
     * Указатель ctor может быть нулевым, в этом случае никакого
     * дополнительного конструирования объекта не производится, а просто
     * зануляется выделенная память.
     */
    void* (*ctor)(void* self, va_list* app);

    /*
     * Указатель на функцию-деструктор. В качестве аргумента функция принимает
     * указатель на объект и осуществляет необходимые операции по очистке:
     * закрытие файлов, освобождение дополнительно выделенной памяти и т.д.
     *
     * Указатель dtor может быть нулевым, в этом случае очистка не
     * производится, а просто освобождается выделенная память.
     *
     * Деструктор должен вернуть тот указатель, который передавался в
     * качестве аргумента конструктору (обычно это просто self).
     */
    void* (*dtor)(void* self);

    /*
     * Указатель на реализацию виртуальной функции, которая будет вызываться в
     * зависимости от реального типа объекта. В данном примере есть всего одна
     * виртуальная функция, draw. Если задача требует большего количества
     * виртуальных функций, все они должны быть добавлены сюда с соответствующими
     * прототипами.
     *
     * Первый аргумент функции (self) – указатель на объект.
     */
    void (*draw)(const void* self);

    void (*check)(const void* self, void* desk);

};

// Функция создания объекта. Первый аргумент — указатель на структуру-описание
// класса (типа Class). Прочие аргументы будут переданы конструктору (ctor).
// Функция возвращает указатель на созданный и проинициализированный объект.
void* new(const void* class, ...);

// Функция уничтожения объекта. Аргумент item — указатель на объект
// (который был ранее возвращен функцией new). Перед освобождением памяти
// вызывает деструктор dtor (при его наличии).
void delete(void* item);

// Виртуальная функция draw. Аргумент self — указатель на объект. В зависимости от
// класса объекта будет вызвана соответствующая реализация draw.
void draw(const void* self);
void check(const void* self, desk* desk);
#endif